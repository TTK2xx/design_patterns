package com.ttk.flyweight;

/**
 * @Author TTK
 * @Description 测试享元模式
 *      1）概念：
 *          - 运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建
 *            的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。
 *      2）享元（Flyweight ）模式中存在以下两种状态：
 *          - 内部状态，即不会随着环境的改变而改变的可共享部分。
 *          - 外部状态，指随环境改变而改变的不可以共享的部分。
 *          - 享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。
 *      3）享元模式的主要有以下角色：
 *          - 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公
 *            共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法
 *            来设置外部数据（外部状态）。
 *          - 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元
 *            类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享
 *            元类提供唯一的享元对象。
 *          - 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不
 *            能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过
 *            实例化创建。
 *          - 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元
 *            对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在
 *            的话，则创建一个新的享元对象。
 *      4）优点：
 *          - 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能
 *          - 享元模式中的外部状态相对独立，且不影响内部状态
 *      5）缺点：
 *          - 为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂
 *      6）使用场景：
 *          - 一个系统有大量相同或者相似的对象，造成内存的大量耗费。
 *          - 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
 *          - 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应
 *            当在需要多次重复使用享元对象时才值得使用享元模式。
 * @Version 1.0
 */
public class Client {
    public static void main(String[] args) {
        //获取I图形对象
        AbstractBox box1 = BoxFactory.getInstance().getShape("I");
        box1.display("灰色");

        //获取L图形对象
        AbstractBox box2 = BoxFactory.getInstance().getShape("L");
        box2.display("绿色");

        //获取O图形对象
        AbstractBox box3 = BoxFactory.getInstance().getShape("O");
        box3.display("灰色");

        //获取O图形对象
        AbstractBox box4 = BoxFactory.getInstance().getShape("O");
        box4.display("红色");

        System.out.println("两次获取到的O图形对象是否是同一个对象：" + (box3 == box4));
    }
}
